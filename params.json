{"name":"Lois","tagline":"Golang like channels for java","body":"#Lois\r\n####Golang like channels for java\r\n\r\nLois is a Java library that provides golang like channel abstraction and implementation.\r\nGo's channel abstraction is heavily influenced by Communicating Sequential Processes(CSP) and\r\nProcess calculus. The pivotal idea behind concurrent process communicating over channels is\r\n\r\n**\"Don't communicate by sharing state, share state by communicating\"**\r\n\r\nLois brings the power and flexibility of this concurrent computational paradigm to Java.\r\n\r\n###Channel\r\n####A conduit for communication and coordination\r\n\r\nIn Lois a channel is a mechanism for two independent threads of execution or **Routines** to either communicate or\r\ncoordinate with each other. A channel can be typed and will carry a message only of the appropriate type, it can\r\nalso be untyped allowing it to carry a message of any type.\r\n\r\n```java\r\n/**\r\n* This is a typed channel\r\n*/\r\nChannel<String> typedChannel = new SimpleChannel<String>();\r\n\r\n/**\r\n* This is an untyped channel\r\n*/\r\nChannel untypedChannel = new SimpleChannel();\r\n```\r\n\r\n####Send and Receive\r\n\r\nSend and receive are the most basic operations on a channel. The variants of these operations are the fundamental\r\nway in which threads and Routines use to communicate and coordinate with each other. Let's look at the basic send\r\nand receive operations over a channel.\r\n\r\n```java\r\n/**\r\n * Thread 1 send's a message over a typed channel\r\n */\r\ntypedChannel.send(\" Hello \");\r\n\r\n/**\r\n * Thread 2 receives a message over a typed channel\r\n */\r\nString message = typedChannel.receive();\r\n```\r\n\r\nIn the above example we see how a channel can be used to send and receive messages between concurrent threads or Routines.\r\nBoth send and receive can block and place the calling thread in a wait state until the message is either sendable or\r\nreceivable.\r\n\r\n```java\r\nChannel<String> typedChannel = new SimpleChannel<String>();\r\n\r\ntypedChannel.send(\" Hello \");\r\n\r\n/**\r\n * Since a SimpleChannel can carry only one message\r\n * at a time, calling send on the channel when the\r\n * previous message hasn't been \"received\" yet\r\n * blocks the thread and puts it in a wait state.\r\n */\r\ntypedChannel.send(\" World! \");\r\n```\r\n\r\nSimilarly receive blocks on a channel until there is a message to receive on it.\r\n\r\n```java\r\n /**\r\n * Receive blocks the thread and put's it in a wait\r\n * state until there is something to receive over\r\n * the channel.\r\n */\r\nString message = typedChannel.receive();\r\n```\r\n\r\nOne can use variants of send and receive with timeouts to avoid blocking threads indefinitely.\r\n\r\n```java\r\n/**\r\n * A variant of send that takes a long and a TimeUnit to\r\n * timeout on a channel. The following code waits for 10\r\n * milliseconds and timesout to throw a  TimeoutException.\r\n */\r\ntypedChannel.send(\" time's running out! \",10, TimeUnit.MILLISECONDS);\r\n\r\n/**\r\n * A variant of receive that takes a long and a TimeUnit to\r\n * timeout on a channel. The following code waits for 10\r\n * milliseconds and timesout to throw a  TimeoutException.\r\n */\r\ntypedChannel.receive(10, TimeUnit.MILLISECONDS);\r\n```\r\n\r\nOne can also use non blocking variants of send and receive.\r\n\r\n```java\r\n/**\r\n * A non blocking variant of send that attempts to send a\r\n * message over the channel. It returns \"true\" if the\r\n * message could be successfully sent, or a false if the\r\n * message could not be sent over the channel.\r\n */\r\ntypedChannel.trySend(\" trying to send \");\r\n\r\n/**\r\n * A non blocking variant of receive that attempts to\r\n * receive a message over the channel. It returns the\r\n * message if a message was successfully received, or\r\n * a \"null\" if a message could not be received over\r\n * the channel.\r\n */\r\ntypedChannel.tryReceive();\r\n```\r\n\r\nOne can also check whether a channel is ready to send or receive messages by calling **isSendable** and **isReceivable**\r\non the channel. However, if a channel is being shared by multiple threads that send and multiple threads that receive\r\nthen these can't be safely used to send/receive because the state of the channel could be modified by the time a\r\nsend/receive is called.\r\n\r\n```java\r\n/**\r\n * Return's true if the channel has space to accept\r\n * messages\r\n */\r\nchannel.isSendable();\r\n\r\n/**\r\n * Return's true if the channel has atleast one message\r\n * that can be received.\r\n */\r\nchannel.isReceivable();\r\n```\r\n\r\n####Closed for business\r\n\r\nA channel can be in one of two states; either **open** or **closed**. By default, at creation all channel's are open\r\nand can send or receive messages freely. But a channel can be closed and once closed cannot be opened again.\r\n\r\n```java\r\n/**\r\n * One can close a channel by calling close on it\r\n */\r\nchannel.close();\r\n```\r\n\r\nOnce a channel is closed trying to send any message's over it will throw a **ChannelClosedException**. One can still\r\nreceive all pending messages in the channel, but once all the pending messages have been received calling receive on\r\nthe channel results in a **ChannelClosedException**.\r\n\r\n```java\r\nchannel.close();\r\n\r\n/**\r\n * Throws a ChannelClosedException\r\n */\r\nchannel.send(\" doomed to fail \");\r\n```\r\n\r\nOne has to think carefully about how and when to close a channel. Since a channel could potentially be shared by multiple\r\nthreads of execution, closing a channel would make it impossible for other channels to send messages over it. One can\r\ncheck whether a channel is open or closed in the following way.\r\n\r\n```java\r\n/**\r\n * Return's true if the channel is open false if closed\r\n */\r\nchannel.isOpen();\r\n```\r\n\r\n####Buffered and Simple channels\r\n\r\nThe difference between a Buffered and a Simple channel is the number of messages each can successfully hold. A simple\r\nchannel can hold only one message in the channel.\r\n\r\n```java\r\n/**\r\n * This is a simple channel\r\n */\r\nChannel simpleChannel = new SimpleChannel();\r\n\r\nsimpleChannel.send(\"hello\");\r\n\r\n/**\r\n * This blocks if the first message isn't received yet\r\n * because a SimpleChannel has a capacity of one message\r\n */\r\nsimpleChannel.send(\"world\");\r\n```\r\n\r\nA buffered channel on the other hand can hold a variable number of messages. The capacity of a buffered channel is\r\nspecified at the time of creation.\r\n\r\n```java\r\n/**\r\n * A buffered channel with a capacity of 3\r\n */\r\nChannel bufferedChannel = new BufferedChannel(3);\r\n\r\nchannel.send(1);\r\nchannel.send(2);\r\nchannel.send(3);\r\n\r\n/**\r\n * This blocks on send if the first 3 messages haven't\r\n * been received yet.\r\n */\r\nchannel.send(4);\r\n```\r\n\r\nSimple channels are useful for fine grained coordination while buffered channels are performant and useful when dealing\r\nwith multiple or bursty senders and receivers.\r\n\r\n#### Send only or Receive only channels\r\n\r\nA channel by default can be used for full duplex communication, i.e it can be used to both send and receive messages by\r\nany thread that has access to it. However, most of the time a thread would only use a channel to either send or recieve\r\nmessages exclusively. To enforce this behaviour one can use send or recieve channels\r\n\r\n```java\r\n/**\r\n * This channel can only be used to send messages\r\n */\r\nSendChannel sendChannel = new SimpleChannel();\r\nsendChannel.send(\"I can send only\");\r\n\r\n/**\r\n * This channel can only be used to receive messages\r\n */\r\nReceiveChannel receiveChannel = new SimpleChannel();\r\nreceiveChannel.receive();\r\n```\r\n\r\n###Routines\r\n\r\nRoutines are simple runnables that can be run by Lois on independent threads.\r\n\r\n```java\r\n/**\r\n* Simple routine that accepts a channel as a constructor\r\n* parameter.\r\n*/\r\nRoutine sampRoutine = new SampRoutine(stringChannel);\r\n\r\n/**\r\n* Start the routine on an independent thread which can then\r\n* receive or send messages over the channel.\r\n*/\r\nLois.go(sampRoutine);\r\n```\r\n\r\nOne need not use routines to use channels. Any way of sharing reference to a channel by independent threads should\r\nenable them to use the channel to send and receive messages.\r\n\r\n###Value vs Reference\r\n\r\nThe value of **\"Don't communicate by sharing state, share state by communicating\"** can only be realized if there is\r\nno shared state among concurrent threads. To accomplish this one should refrain from sharing references to the same\r\nobject, hence any message that is sent over a channel is passed on as a value rather than a reference. This is\r\naccomplished by deep cloning the message before sending it across. This makes sure that multiple threads can have access\r\nto the value of the message without a danger of shared state being accidentally modified.\r\n\r\nHowever, there is one exception to this pass by value semantic. Any message that is a channel will be passed by reference.\r\nThis ensures that a channel can be sent over channels while still retaining the ability to communicate/coordinate with\r\nany threads that still have a reference to the sent/received channel. This leads to incredible flexibility and power\r\nwhere channels can be used to dynamically alter the network of communicating and coordinating nodes at runtime.\r\n\r\nIf one can constrain their messages to be immutable, then they can take advantage of the more efficient pass by reference\r\n channel mechanisms. The **BufferedPassByRefChannel** or **SimplePassByRefChannel** are pass by reference alternatives\r\nto **BufferedChannel** and **SimpleChannel**.\r\n\r\n###Higher order channel usage\r\n\r\nLois also provides several simple ways of connecting channels together to create useful patterns.\r\n\r\n#####Multiplexing several channels into one\r\n\r\nThe **mux** call multiplexes the messages from several source channels onto one sink channel.\r\n\r\n```java\r\n/**\r\n * Send only channels that will be multiplexed\r\n */\r\nSendChannel sourceChannel1 = new SimpleChannel();\r\nSendChannel sourceChannel2 = new BufferedChannel(3);\r\n\r\n/**\r\n * Receive only channel that will be used to output\r\n * the muxed messages\r\n */\r\nReceiveChannel combinedChannel = new SimpleChannel();\r\n\r\n/**\r\n * A variadic method that muxes source channels into\r\n * the sink channel. It takes all messages recieved on\r\n * souceChannels and transfers them to the combined\r\n * channel.\r\n */\r\nLois.mux(combinedChannel,sourceChannel1, sourceChannel2);\r\n```\r\n\r\n#####Demultiplexing a single channel into several\r\n\r\nThe **deMux** call de-multiplexes the messages from a single source channel onto several sink channels.\r\n\r\n```java\r\n/**\r\n * Receive only channel that will be Demultiplexed\r\n */\r\nReceiveChannel sourceChannel = new SimpleChannel();\r\n\r\n/**\r\n * Send only channels that will be used to output\r\n * the Demuxed messages\r\n */\r\nSendChannel sinkChannel1 = new SimpleChannel();\r\nSendChannel sinkChannel2 = new SimpleChannel();\r\n\r\n/**\r\n * A variadic method that Demuxes source channel into\r\n * the sink channels. It takes all messages recieved on\r\n * souceChannel and transfers them to exactly one of\r\n * the sink channels\r\n */\r\nLois.deMux(sourceChannel,sinkChannel1, sinkChannel2);\r\n```\r\n\r\n#####Multicasting\r\n\r\nThe **multiCast** call multicasts the messages from a single source channel onto several sink channels.\r\n\r\n```java\r\n/**\r\n * Receive only channel that will be multicasted\r\n */\r\nReceiveChannel sourceChannel = new SimpleChannel();\r\n\r\n/**\r\n * Send only channels that will be used to output\r\n * the multicasted messages\r\n */\r\nSendChannel sinkChannel1 = new SimpleChannel();\r\nSendChannel sinkChannel2 = new SimpleChannel();\r\n\r\n/**\r\n * A variadic method that multicasts source channel into\r\n * the sink channels. It takes all messages recieved on\r\n * souceChannel and sends them on all of  the sink channels\r\n */\r\nLois.multiCast(sourceChannel,sinkChannel1, sinkChannel2);\r\n```\r\n\r\nThese are just some simple ways in which channels can be combined, they are by no means exhaustive and similar higher\r\norder constructs between can be built with ease, one is only limited by one's imagination.\r\n\r\n###Examples\r\n\r\n####Simple parllelization\r\n\r\nIn this example we create a simple web page downloader using multiple parallel crawlers\r\nand a web page persister.\r\n\r\n```java\r\n//Create a list to hold worker channels\r\nList<Channel<WebPage>> crawlerChannels = new ArrayList<Channel<WebPage>>();\r\n\r\n//create 10 crawlers each with a dedicated channel over which they will\r\n//send the webpages they crawl.\r\nfor (int workerCount=0;workerCount<10;workerCount++){\r\n\r\n    //create a crawlerChannel\r\n    Channel<WebPage> crawlerChannel = new BufferedChannel<WebPage>(10);\r\n\r\n    //run a crawler on an independent thread with a beginning url and\r\n    //a crawlerChannel over which to send web pages\r\n    Lois.go(new Crawler(getBeginUrl(), crawlerChannel));\r\n\r\n    //add the crawler channel to list of crawlerchannels\r\n    crawlerChannels.add(crawlerChannel);\r\n}\r\n\r\n//create a sink channel to consume messages from all the crawler channels\r\nSendChannel<WebPage> sinkChannel = new BufferedChannel<WebPage>(10);\r\n\r\n//multiplex crawler channels on to a sink channel\r\nLois.mux(sinkChannel, crawlerChannels);\r\n\r\n//persist webpages on disk\r\nLois.go(new WebPagePersister(sinkChannel));\r\n```\r\n\r\n####Rudimentary Connection Pool\r\n\r\nIn this example we create a simple, threadsafe connection pool.\r\n\r\n```java\r\n//creates a list of 5 connections\r\nList<Connection> connectionList = ConnectionFactory.createConnections(\"localhost\", 80, 5);\r\n\r\n//create a BufferedChannel to hold 5 connections\r\nChannel<Connection> connectionPoolChannel = new BufferedChannel<Connection>(5);\r\n\r\nfor (Connection connection: connectionList){\r\n    connectionPoolChannel.send(connection);\r\n}\r\n\r\n//to take a connection from the pool any thread can receive a connection\r\nConnection connection = connectionPoolChannel.receive();\r\n\r\n//to release a connection any thread can send it to the channel\r\nconnectionPoolChannel.send(connection);\r\n```\r\n\r\n##Maven Artifact\r\n\r\nAdd the following repository to your pom.xml\r\n\r\n```xml\r\n    <repository>\r\n      <id>clojars</id>\r\n      <name>Clojars repository</name>\r\n      <url>https://clojars.org/repo</url>\r\n    </repository>\r\n```\r\n\r\nAnd add the following dependency to start using Lois in your maven project.\r\n\r\n```xml\r\n   <dependency>\r\n     <groupId>com.flipkart.lego</groupId>\r\n     <artifactId>lois</artifactId>\r\n     <version>1.1.2</version>\r\n   </dependency>\r\n```\r\n\r\n##Documentation\r\n\r\nThe api docs can be found [here](http://flipkart-incubator.github.io/Lois/javadoc/index.html)\r\n\r\n##Contribution, Bugs and Feedback\r\n\r\nFor bugs, questions and discussions please use the [Github Issues](https://github.com/flipkart-incubator/Lois/issues).\r\nPlease follow the [contribution guidelines](https://github.com/flipkart-incubator/Lois/blob/master/CONTRIBUTING.md) when submitting pull requests.\r\n\r\n##License\r\n\r\nCopyright 2014 Flipkart Internet, pvt ltd.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}